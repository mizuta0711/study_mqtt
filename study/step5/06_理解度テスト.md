# 理解度テスト

## 📝 第5章の理解度を確認しましょう

全10問です。8問以上正解で合格です！

---

## 問題1：基本概念（選択式）

センサーのステータス情報を送信する際、最も適切な設定はどれですか？

A) QoS 0、Retain無効
B) QoS 0、Retain有効
C) QoS 1、Retain無効
D) QoS 1、Retain有効

<details>
<summary>解答を見る</summary>

**正解: D) QoS 1、Retain有効**

**解説:**
- ステータス情報は確実に届ける必要があるため、QoS 1以上が適切
- 新規Subscriberが接続時にすぐにステータスを知るために、Retainを有効にする
- これにより、デバイスが再起動してもステータスが保持される

</details>

---

## 問題2：温度データ送信（選択式）

1秒ごとに送信される温度データに最も適したQoSレベルはどれですか？

A) QoS 0
B) QoS 1
C) QoS 2
D) どれでも同じ

<details>
<summary>解答を見る</summary>

**正解: A) QoS 0**

**解説:**
- リアルタイムセンサーデータはQoS 0が最適
- 次のデータがすぐ来るため、パケットロスは許容できる
- 高速性とスループットを優先
- QoS 1/2を使うとオーバーヘッドが大きくなり、リアルタイム性が低下

</details>

---

## 問題3：トピック設計（記述式）

以下の要件を満たすトピック階層を設計してください：
- 3つの部屋（リビング、寝室、キッチン）
- 各部屋に温度センサーと湿度センサー
- センサーのステータス情報

<details>
<summary>解答例を見る</summary>

**解答例:**

```
rooms/
  ├─ living-room/
  │   ├─ sensors/
  │   │   ├─ temperature
  │   │   └─ humidity
  │   └─ status
  ├─ bedroom/
  │   ├─ sensors/
  │   │   ├─ temperature
  │   │   └─ humidity
  │   └─ status
  └─ kitchen/
      ├─ sensors/
      │   ├─ temperature
      │   └─ humidity
      └─ status
```

**ポイント:**
- 階層的な構造で整理
- ワイルドカード購読が可能（例: `rooms/+/sensors/temperature` で全部屋の温度を購読）
- 拡張性が高い

</details>

---

## 問題4：データ可視化（選択式）

matplotlibでリアルタイムグラフを更新する際、パフォーマンスを向上させるために推奨されるオプションはどれですか？

A) `cache_frame_data=True`
B) `blit=True`
C) `interval=10`
D) `repeat=False`

<details>
<summary>解答を見る</summary>

**正解: B) `blit=True`**

**解説:**
- `blit=True` は変更された部分のみを再描画するため、高速化される
- 全体を毎回再描画する必要がなくなる
- ただし、`update()` 関数は必ずアーティストのタプルを返す必要がある

```python
ani = animation.FuncAnimation(
    fig, update,
    interval=1000,
    blit=True  # 高速化
)
```

</details>

---

## 問題5：エラーハンドリング（記述式）

MQTT接続が切断された場合の適切な対応を3つ挙げてください。

<details>
<summary>解答を見る</summary>

**解答例:**

1. **自動再接続**
   - 指数バックオフを使用して再接続を試みる
   - 無限ループを避けるため、最大試行回数を設定

2. **購読の復元**
   - 再接続後、購読していたトピックを再度購読する
   - 購読リストを保存しておく

3. **ログ記録**
   - 切断の理由とタイムスタンプを記録
   - トラブルシューティングに役立つ

```python
def on_disconnect(client, userdata, rc):
    if rc != 0:
        print(f"⚠️  予期しない切断: {rc}")
        reconnect_with_backoff(client)
```

</details>

---

## 問題6：データ構造（選択式）

リアルタイムグラフで最新50個のデータのみを保持したい場合、最も適したPythonのデータ構造はどれですか？

A) list
B) dict
C) deque
D) set

<details>
<summary>解答を見る</summary>

**正解: C) deque**

**解説:**
```python
from collections import deque

# maxlenを指定すると、自動的に古いデータを削除
data = deque(maxlen=50)
data.append(25.5)  # 51個目を追加すると、最も古いデータが削除される
```

**メリット:**
- メモリ効率が良い
- 自動的にサイズ制限
- 高速な追加・削除

</details>

---

## 問題7：実装問題

以下のコードの誤りを修正してください。

```python
import paho.mqtt.client as mqtt
import matplotlib.pyplot as plt

client = mqtt.Client()
client.connect("localhost", 1883, 60)

data = []

def on_message(client, userdata, msg):
    temp = float(msg.payload.decode())
    data.append(temp)

client.subscribe("sensor/temperature")
client.on_message = on_message

plt.plot(data)
plt.show()
```

<details>
<summary>解答を見る</summary>

**誤りと修正:**

1. **CallbackAPIVersionの指定がない**
2. **MQTTループが開始されていない**
3. **matplotlibのリアルタイム更新がない**

**修正版:**

```python
import paho.mqtt.client as mqtt
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from collections import deque

# CallbackAPIVersionを指定
client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION1)
client.connect("localhost", 1883, 60)

data = deque(maxlen=50)

def on_message(client, userdata, msg):
    temp = float(msg.payload.decode())
    data.append(temp)

client.subscribe("sensor/temperature")
client.on_message = on_message

# MQTTループを開始
client.loop_start()

# グラフの設定
fig, ax = plt.subplots()
line, = ax.plot([], [])

def update(frame):
    if len(data) > 0:
        line.set_data(range(len(data)), list(data))
        ax.set_xlim(0, len(data))
        ax.set_ylim(min(data)-2, max(data)+2)
    return line,

# アニメーション
ani = animation.FuncAnimation(fig, update, interval=1000, blit=True)
plt.show()

# クリーンアップ
client.loop_stop()
client.disconnect()
```

</details>

---

## 問題8：システム設計（記述式）

温度センサーシステムで、以下の3種類のデータを送信します。それぞれに適したQoSレベルとRetain設定を提案し、理由を説明してください。

1. リアルタイム温度データ（1秒ごと）
2. デバイスステータス（ONLINE/OFFLINE）
3. 高温アラート

<details>
<summary>解答を見る</summary>

**解答例:**

| データ種類 | QoS | Retain | 理由 |
|:---|:---:|:---:|:---|
| リアルタイム温度 | 0 | ❌ | 次のデータがすぐ来るため、高速性を優先。Retainは不要（最新データのみ意味がある） |
| デバイスステータス | 1 | ✅ | 確実に届ける必要があり、新規Subscriberもすぐに状態を把握できるようにする |
| 高温アラート | 2 | ❌ | 絶対に失ってはいけないが、古いアラートを保持する必要はない |

**ポイント:**
- データの重要度と性質に応じて使い分ける
- リアルタイム性とメッセージの確実性のトレードオフを考慮
- Retainは「最新の状態」を保持したい場合に有効

</details>

---

## 問題9：パフォーマンス（選択式）

大量のセンサーデータを処理する際のパフォーマンス最適化として、適切でないものはどれですか？

A) dequeでデータ量を制限する
B) matplotlibのblitオプションを使う
C) すべてのデータをQoS 2で送信する
D) グラフの更新間隔を調整する

<details>
<summary>解答を見る</summary>

**正解: C) すべてのデータをQoS 2で送信する**

**解説:**
- QoS 2は最も重いオーバーヘッドがあり、大量データには不適切
- リアルタイムセンサーデータはQoS 0で十分
- QoS 2は本当に失ってはいけないデータ（アラート等）にのみ使用すべき

**適切な最適化:**
- A: メモリ使用量を制限できる
- B: グラフ描画を高速化できる
- D: CPU負荷を軽減できる

</details>

---

## 問題10：総合問題

IoTセンサーシステムの完全な設計を行ってください。以下の要件を満たすシステムを設計し、トピック構造、QoS設定、主要なコンポーネントを説明してください。

**要件:**
- 5つの温度センサー（異なる場所）
- リアルタイムダッシュボード
- データロギング（SQLite）
- 異常温度の検出とアラート
- センサーの死活監視

<details>
<summary>解答例を見る</summary>

**システム設計:**

### 1. トピック構造

```
sensors/
  ├─ location-1/
  │   ├─ temperature (QoS 0)
  │   └─ status (QoS 1, Retain)
  ├─ location-2/
  │   ├─ temperature (QoS 0)
  │   └─ status (QoS 1, Retain)
  └─ ...

alerts/
  └─ temperature (QoS 2)

system/
  └─ health (QoS 1)
```

### 2. コンポーネント

**Publisher（センサー側）:**
```python
# 温度データ: QoS 0で高速送信
client.publish("sensors/location-1/temperature", temp, qos=0)

# ステータス: QoS 1 + Retain
client.publish("sensors/location-1/status", "ONLINE", qos=1, retain=True)

# Last Will設定
client.will_set("sensors/location-1/status", "OFFLINE", qos=1, retain=True)

# 異常値検出時: QoS 2で確実に送信
if temp > 30 or temp < 10:
    client.publish("alerts/temperature", alert_data, qos=2)
```

**Subscriber（ダッシュボード）:**
```python
# 全センサーを購読
client.subscribe("sensors/+/temperature", qos=0)
client.subscribe("sensors/+/status", qos=1)
client.subscribe("alerts/#", qos=2)

# リアルタイムグラフ表示
# matplotlibでアニメーション
```

**Logger:**
```python
# 全データをSQLiteに記録
client.subscribe("sensors/#", qos=1)

def on_message(client, userdata, msg):
    save_to_database(msg.topic, msg.payload, msg.timestamp)
```

**監視システム:**
```python
# ステータス監視
client.subscribe("sensors/+/status", qos=1)

# OFFLINEになったらアラート
def on_message(client, userdata, msg):
    if msg.payload.decode() == "OFFLINE":
        send_alert(f"{msg.topic}がオフラインになりました")
```

### 3. データフロー

```
[Sensors] --publish--> [Broker] --subscribe--> [Dashboard]
                          |                       [Logger]
                          |                       [Monitor]
                          v
                      [Alerts] --> [通知システム]
```

### 4. ポイント
- スケーラブル（センサー追加が容易）
- 信頼性（適切なQoS設定）
- 監視可能（死活監視とアラート）
- データ永続化（ロギング）

</details>

---

## 📊 採点

- **8〜10問正解**: 🎉 合格！第6章に進めます
- **6〜7問正解**: 😊 もう一息！復習してから再挑戦
- **5問以下**: 📚 ドキュメントを見直してから再挑戦しましょう

---

## 🎓 合格した方へ

おめでとうございます！実用的なIoTシステムの構築スキルが身につきました。

**習得したスキル:**
- ✅ センサーシミュレーション
- ✅ リアルタイムデータ可視化
- ✅ 適切なQoS設定
- ✅ エラーハンドリング
- ✅ システム設計の基礎

**次のステップ:**
- 第6章でMQTTの学習をまとめましょう
- 実際のハードウェア（ESP32など）への応用を検討
- クラウドMQTTブローカーの活用を学習

---

**前の章**: [05_応用コード集.md](./05_応用コード集.md)
**次の章**: 第6章：まとめと発展
