# 第4章 理解度確認テスト
## QoS・Retain・Willを試す

## 📋 テスト問題（全10問）

---

### 問題1：QoSレベル（選択式）

リアルタイム性が重要で、データが少し欠けても問題ない温度センサー（1秒ごとに送信）には、どのQoSレベルが最適ですか？

A) QoS 0
B) QoS 1
C) QoS 2
D) どれでも同じ

---

### 問題2：QoSの動作（マッチング）

以下のQoSレベルと動作を正しく結び付けてください。

1. QoS 0
2. QoS 1
3. QoS 2

A) 4ウェイハンドシェイク、重複なし
B) 確認応答なし、最速
C) ACK確認あり、重複の可能性

**回答**:
- 1 → ____
- 2 → ____
- 3 → ____

---

### 問題3：Retain機能（正誤問題）

以下の文章が正しければ○、間違っていれば×を付けてください。

1. Retainメッセージは、ブローカーが永久に保存する（　）
2. 同じトピックに複数のRetainメッセージを保存できる（　）
3. 新しいSubscriberは、Retainメッセージを即座に受信する（　）
4. 空のペイロードで送信すると、Retainメッセージが削除される（　）

---

### 問題4：Retain実装（実装問題）

デバイスのステータス（"ONLINE"）をRetainメッセージとして送信するコードを書いてください。
- トピック: `device/status`
- QoS: 1

**回答欄**:
```python




```

---

### 問題5：Last Will（記述式）

Last Willメッセージが送信されるのは、どのような場合ですか？2つ挙げてください。

**回答欄**:
1. ________________________________________
2. ________________________________________

---

### 問題6：Last Will設定（実装問題）

以下の要件を満たすLast Willを設定してください：
- トピック: `sensors/temp01/status`
- メッセージ: "OFFLINE"
- QoS: 2
- Retain: 有効

**回答欄**:
```python




```

---

### 問題7：Last Willのタイミング（選択式）

`will_set()`を呼び出すべきタイミングはいつですか？

A) `connect()`の前
B) `connect()`の後
C) `publish()`の前
D) いつでもよい

---

### 問題8：QoS + Retain（記述式）

PublisherがQoS 2でRetainメッセージを送信し、SubscriberがQoS 0で購読した場合、実際に適用されるQoSレベルは何ですか？

**回答欄**: ____________________________

---

### 問題9：使い分け（マッチング）

以下のユースケースに最適な機能を選んでください。

1. 決済トランザクション
2. デバイスの最新ステータス
3. デバイスの異常切断検知

A) Last Will
B) Retain
C) QoS 2

**回答**:
- 1 → ____
- 2 → ____
- 3 → ____

---

### 問題10：総合問題（実装問題）

センサーデバイスを実装してください。

**要件**:
- センサーID: `Sensor01`
- Last Will: トピック`sensors/Sensor01/status`、メッセージ"OFFLINE"、QoS 1、Retain有効
- 接続成功時: ステータス"ONLINE"をRetainで送信（QoS 1）
- 1秒ごとに温度データ（20〜30℃のランダム値）を送信（QoS 0）

**回答欄**:
```python
import paho.mqtt.client as mqtt
import random
import time

# ここにコードを記述












```

---
---

## ✅ 解答と解説

### 問題1の解答

**正解: A (QoS 0)**

**理由**:
- 1秒ごとにデータが送信されるため、1つ欠けても次のデータが来る
- リアルタイム性が重要なので、高速処理が優先
- QoS 0が最速

**不正解の選択肢**:
- B/C: 確実だが遅い。連続データには不要
- D: QoSレベルによって速度が大きく異なる

---

### 問題2の解答

**正解**:
- 1 → **B** （確認応答なし、最速）
- 2 → **C** （ACK確認あり、重複の可能性）
- 3 → **A** （4ウェイハンドシェイク、重複なし）

**詳細**:

**QoS 0**: Fire and Forget
- 送信して終わり
- 最速だが保証なし

**QoS 1**: At least once
- PUBACK で確認
- 重複する可能性

**QoS 2**: Exactly once
- PUBREC → PUBREL → PUBCOMP
- 重複なし、最も確実

---

### 問題3の解答

**正解**:
1. × **間違い**
2. × **間違い**
3. ○ **正しい**
4. ○ **正しい**

**解説**:

**1. Retainメッセージは永久に保存される**
- ❌ 新しいRetainメッセージで上書きされる
- ブローカー再起動で消える場合もある

**2. 同じトピックに複数のRetainメッセージを保存できる**
- ❌ 1トピックにつき1つだけ
- 新しいメッセージが古いメッセージを上書き

**3. 新しいSubscriberは即座に受信**
- ✅ 正しい。これがRetainの主要な機能

**4. 空のペイロードで削除**
- ✅ 正しい
```python
client.publish("topic", "", retain=True)  # 削除
```

---

### 問題4の解答

```python
import paho.mqtt.client as mqtt

client = mqtt.Client()
client.connect("localhost", 1883, 60)
client.publish("device/status", "ONLINE", qos=1, retain=True)
client.disconnect()
```

**採点基準**:
- [ ] `qos=1` が指定されている
- [ ] `retain=True` が指定されている
- [ ] トピック名が正確

---

### 問題5の解答

**正解例**:
1. **ネットワーク障害でクライアントが切断された場合**
2. **プログラムがクラッシュした場合**

**その他の正答例**:
- Ctrl+Cで強制終了
- `disconnect()`を呼ばずに終了
- キープアライブタイムアウト

**送信されないケース**:
- ❌ `disconnect()`で正常終了した場合

---

### 問題6の解答

```python
client = mqtt.Client()

client.will_set(
    topic="sensors/temp01/status",
    payload="OFFLINE",
    qos=2,
    retain=True
)

client.connect("localhost", 1883, 60)
```

**採点基準**:
- [ ] `will_set()`を使用
- [ ] トピック名が正確
- [ ] `qos=2`が指定されている
- [ ] `retain=True`が指定されている
- [ ] `connect()`の前に呼んでいる

**重要**: `will_set()`は`connect()`の**前**に呼ぶ！

---

### 問題7の解答

**正解: A (`connect()`の前)**

**理由**:
Last Willは接続時にブローカーに登録されるため、`connect()`の前に設定する必要があります。

**正しいコード**:
```python
client = mqtt.Client()
client.will_set("topic", "msg")  # ← 先に設定
client.connect("localhost", 1883)  # ← その後接続
```

**間違ったコード**:
```python
client = mqtt.Client()
client.connect("localhost", 1883)
client.will_set("topic", "msg")  # ← 遅い！効果なし
```

---

### 問題8の解答

**正解**: QoS 0

**理由**:
PublisherとSubscriberで指定したQoSのうち、**低い方が適用**されます。

| Publisher QoS | Subscriber QoS | 実際のQoS |
|:---:|:---:|:---:|
| 2 | 0 | **0** |
| 2 | 1 | 1 |
| 1 | 2 | 1 |
| 0 | 2 | 0 |

**覚え方**: 低い方に合わせる

---

### 問題9の解答

**正解**:
- 1 → **C** (QoS 2)
- 2 → **B** (Retain)
- 3 → **A** (Last Will)

**理由**:

**1. 決済トランザクション → QoS 2**
- 重複も欠損も許されない
- 正確に1回だけ処理する必要

**2. デバイスの最新ステータス → Retain**
- 新規接続時に最新状態を知りたい
- Retainで保存しておく

**3. デバイスの異常切断検知 → Last Will**
- 予期しない切断を自動検知
- Last Willが自動送信される

---

### 問題10の解答

```python
import paho.mqtt.client as mqtt
import random
import time

SENSOR_ID = "Sensor01"

def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print(f"✅ {SENSOR_ID} 接続成功")
        # ステータスをONLINEに（QoS 1 + Retain）
        client.publish(
            f"sensors/{SENSOR_ID}/status",
            "ONLINE",
            qos=1,
            retain=True
        )

client = mqtt.Client(SENSOR_ID)

# Last Will設定（connect前に！）
client.will_set(
    topic=f"sensors/{SENSOR_ID}/status",
    payload="OFFLINE",
    qos=1,
    retain=True
)

client.on_connect = on_connect
client.connect("localhost", 1883, 60)
client.loop_start()

print(f"🌡️  {SENSOR_ID} 稼働中...")

try:
    while True:
        # 温度データ（QoS 0）
        temp = round(random.uniform(20, 30), 1)
        client.publish(
            f"sensors/{SENSOR_ID}/temperature",
            str(temp),
            qos=0
        )
        print(f"📊 温度: {temp}°C")
        time.sleep(1)
except KeyboardInterrupt:
    print("\n⚠️  異常終了")
    exit(0)  # disconnect()を呼ばずに終了 → Last Will発火
```

**採点基準**:
- [ ] Last Willが正しく設定されている
- [ ] `connect()`の前に`will_set()`を呼んでいる
- [ ] `on_connect()`でONLINEを送信
- [ ] ONLINEはQoS 1 + Retain
- [ ] 温度データはQoS 0
- [ ] `random.uniform(20, 30)`で温度生成

---

## 🎯 採点基準

- **8問以上正解**: ✅ 優秀！第5章に進めます
- **6〜7問正解**: △ 基本は理解できています。復習推奨
- **5問以下**: ⚠️ もう一度、メインドキュメントを読み直しましょう

---

## 📝 よくある間違い

| よくある間違い | 正しい理解 |
|:---|:---|
| QoS 2が最速 | QoS 0が最速 |
| Retainは複数保存できる | 1トピック1つだけ |
| Last Willは常に送信 | 異常切断時のみ |
| will_set()の位置 | connect()の前に呼ぶ |

---

**お疲れさまでした！**
MQTTの高度な機能をマスターしました！次は実践的なアプリケーションを作りましょう！

**次の章**: 第5章：応用演習と確認
