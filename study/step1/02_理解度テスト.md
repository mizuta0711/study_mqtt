# MQTT基礎理解度テスト

## 📋 テスト問題（全10問）

このテストは、第1章で学んだMQTTの基礎知識を確認するためのものです。
各問題に答えてから、下の解答セクションで確認してください。

---

### 問題1：MQTTの基本概念（選択式）
MQTTのアーキテクチャとして正しいものはどれですか？

A) クライアント同士が直接接続してメッセージを交換する
B) すべてのメッセージはBrokerを経由して配信される
C) PublisherとSubscriberが1対1で接続する
D) メッセージは必ずデータベースに保存される

---

### 問題2：IoTでの活用理由（記述式）
MQTTがIoTデバイスで広く使われている理由を、3つ挙げてください。

---

### 問題3：トピック構造（選択式）
以下のトピック構造で、`factory/+/temperature` を購読した場合、受信できるメッセージはどれですか？（複数選択）

A) `factory/machine1/temperature`
B) `factory/machine2/temperature`
C) `factory/machine1/status/temperature`
D) `factory/temperature`

---

### 問題4：ワイルドカード（記述式）
トピック `home/#` を購読した場合、どのようなメッセージを受信しますか？具体例を3つ挙げてください。

---

### 問題5：QoSレベルの理解（マッチング）
以下のユースケースに最適なQoSレベルを選んでください。

1. 1秒ごとに送信される温度センサーデータ（多少欠けてもOK）
2. 決済システムのトランザクション通知（重複も欠損も厳禁）
3. ドアの開閉イベント（確実に届ける必要があるが、重複は許容可能）

A) QoS 0
B) QoS 1
C) QoS 2

---

### 問題6：QoSの動作（正誤問題）
以下の文章が正しければ○、間違っていれば×を付けてください。

1. QoS 0は確認応答（ACK）を行わない（　）
2. QoS 1ではメッセージが重複する可能性がある（　）
3. QoS 2は最も高速に配信される（　）
4. PublisherとSubscriberで異なるQoSレベルを指定できる（　）

---

### 問題7：Retain機能（記述式）
以下のシナリオを読んで、Retain機能がどのように動作するか説明してください。

**シナリオ**:
1. センサーAが `sensor/temperature` に "25.5" を送信（Retain=true）
2. その後、誰も購読していない状態が10分間続く
3. ダッシュボードアプリBが `sensor/temperature` を購読開始

→ アプリBは何を受信しますか？なぜですか？

---

### 問題8：Last Will（シナリオ問題）
以下のコードを実行したとき、Last Willメッセージが送信されるケースを2つ挙げてください。

```python
client.will_set("device/status", "OFFLINE", qos=1, retain=True)
client.connect("localhost", 1883)
client.publish("device/status", "ONLINE", retain=True)
# ... 何らかの処理 ...
```

---

### 問題9：通信ポート（選択式）
本番環境でインターネット経由でMQTT通信を行う場合、使用すべきポートはどれですか？

A) 1883（MQTT非暗号化）
B) 8883（MQTT over TLS/SSL）
C) 8083（MQTT over WebSocket）
D) どれでも良い

---

### 問題10：総合理解（実装問題）
以下の要件を満たすMQTTシステムを設計してください。

**要件**:
- 複数の温度センサー（センサー1、センサー2、センサー3）がある
- 各センサーは1秒ごとに温度を送信（少しデータが欠けてもOK）
- ダッシュボードはすべてのセンサーの温度を表示
- センサーが切断された場合、ダッシュボードに「センサーX オフライン」と表示

以下を答えてください：
1. センサーが使用すべきトピック名（3つ）
2. 温度データのQoSレベル
3. Last Willメッセージの設定内容

---
---

## ✅ 解答と解説

### 問題1の解答
**正解: B**

**理由**:
MQTTはPub/Sub型アーキテクチャを採用しており、すべてのメッセージは中央のBroker（仲介サーバー）を経由して配信されます。PublisherとSubscriberは直接接続せず、Brokerを介することで疎結合な通信が実現されます。

**不正解の選択肢**:
- A: これはP2P型通信の説明です
- C: 1対1接続はMQTTの特徴ではありません（1対多も可能）
- D: メッセージの永続化はオプション機能です

---

### 問題2の解答
**正解例**:
1. **軽量でリソース消費が少ない** → バッテリー駆動のセンサーでも長時間動作可能
2. **低帯域幅で動作する** → 通信コストを削減、不安定なネットワークでも使用可能
3. **耐障害性が高い** → 一時的な切断から自動復旧、QoSで配信保証

**その他の正答例**:
- 実装がシンプルで組み込み機器でも利用可能
- 大量のデバイスを効率的に管理できる（スケーラビリティ）
- 双方向通信が可能（センサーからの送信とコマンドの受信）

**解説**:
IoTデバイスは電力、メモリ、ネットワーク帯域に制約があります。MQTTはこれらの制約に対応した設計になっており、HTTPなどの重いプロトコルと比べて圧倒的に効率的です。

---

### 問題3の解答
**正解: A, B**

**理由**:
`+` ワイルドカードは**1階層のみ**にマッチします。

- ✅ A: `factory/machine1/temperature` → `factory/[任意の1階層]/temperature` にマッチ
- ✅ B: `factory/machine2/temperature` → 同上
- ❌ C: `factory/machine1/status/temperature` → 階層が深すぎる（`status`の分だけ多い）
- ❌ D: `factory/temperature` → 中間階層がない

**補足**:
もしCも受信したい場合は `factory/#` を使用すれば、factory配下のすべてのトピックを購読できます。

---

### 問題4の解答
**正解例**:
1. `home/livingroom/temperature`
2. `home/bedroom/humidity`
3. `home/kitchen/light/brightness`

**理由**:
`#` ワイルドカードは**その階層以下のすべて**にマッチします。`home/#` は `home/` で始まるすべてのトピックを購読するため、階層の深さに関係なくすべて受信できます。

**その他の正答例**:
- `home/temperature`（1階層のみ）
- `home/a/b/c/d/e/f`（深い階層）
- `home/garden/sensor/temperature/raw/data`（非常に深い階層）

---

### 問題5の解答
**正解**:
1. **QoS 0** （A）
2. **QoS 2** （C）
3. **QoS 1** （B）

**理由**:

**1. 温度センサーデータ → QoS 0**
- 1秒ごとに送信されるため、1つ欠けても次のデータが来る
- リアルタイム性重視、配信保証は不要
- 最速で処理できる

**2. 決済トランザクション → QoS 2**
- 重複すると二重課金になる → 重複NG
- 欠損すると課金漏れになる → 欠損NG
- コストは高いが確実性が最優先

**3. ドアの開閉イベント → QoS 1**
- イベントの見逃しは許されない → 確実に配信
- 重複は処理側で検出できる → QoS 2ほどの厳密性は不要
- バランスが取れた選択

---

### 問題6の解答
**正解**:
1. ○ **正しい**
2. ○ **正しい**
3. × **間違い**
4. ○ **正しい**

**解説**:

**1. QoS 0は確認応答（ACK）を行わない**
- ✅ 正しい。QoS 0は「Fire and Forget」方式で、送信後は確認しません。

**2. QoS 1ではメッセージが重複する可能性がある**
- ✅ 正しい。ACKが届かなかった場合、再送信されるため重複する可能性があります。

**3. QoS 2は最も高速に配信される**
- ❌ 間違い。QoS 2は4回のハンドシェイクが必要なため、**最も遅い**です。最速はQoS 0です。

**4. PublisherとSubscriberで異なるQoSレベルを指定できる**
- ✅ 正しい。Publisherが指定したQoSとSubscriberが指定したQoSの**低い方**が適用されます。
  - 例: Publisher QoS 2 + Subscriber QoS 1 → 実際はQoS 1で配信

---

### 問題7の解答
**受信内容**: "25.5"

**理由**:
Retain=trueで送信されたメッセージは、Brokerが**永続的に保持**します。新しいSubscriberがトピックを購読した瞬間に、最後に保存されたメッセージが**即座に配信**されます。

**動作の流れ**:
1. センサーAが "25.5" を送信（Retain=true）
2. Brokerがこのメッセージを保存
3. 10分間経過（メッセージは保持され続ける）
4. アプリBが購読開始
5. → Brokerが保存していた "25.5" を**即座に**配信

**メリット**:
新規Subscriberは次のメッセージを待つ必要がなく、現在の状態を即座に知ることができます。これは、デバイスの状態や最新の設定値を表示するダッシュボードなどで非常に便利です。

---

### 問題8の解答
**Last Willが送信されるケース**:

1. **ネットワーク障害でクライアントが切断された場合**
   - Wi-Fiが突然切れた
   - ケーブルが抜けた
   - ルーターがダウンした

2. **クライアントプロセスがクラッシュした場合**
   - プログラムがエラーで強制終了
   - OSがプロセスを強制停止（kill）
   - 電源が切れた

**Last Willが送信されないケース**:
- ❌ `client.disconnect()` で正常に切断した場合
- ❌ プログラムが正常終了した場合

**重要なポイント**:
Last Willは**予期しない切断**を検出するための機能です。正常な切断では送信されないため、オフライン状態を通知したい場合は、切断前に明示的にメッセージを送信する必要があります。

```python
# 正常切断時の推奨パターン
client.publish("device/status", "OFFLINE", retain=True)  # 明示的に送信
client.disconnect()  # 正常切断（Last Willは送信されない）
```

---

### 問題9の解答
**正解: B（8883 - MQTT over TLS/SSL）**

**理由**:
本番環境でインターネット経由の通信を行う場合、セキュリティが最優先です。ポート1883は**平文通信**であり、パケットが盗聴される可能性があります。

**各ポートの説明**:
- **1883**: ❌ 非暗号化 → ローカル環境や学習用途のみ
- **8883**: ✅ TLS/SSL暗号化 → 本番環境で推奨
- **8083**: △ WebSocket（暗号化なし）→ Webアプリだが非推奨
- **8084**: ✅ WebSocket（暗号化あり）→ Webアプリで推奨

**セキュリティのベストプラクティス**:
1. 本番環境では必ず暗号化ポート（8883または8084）を使用
2. クライアント証明書による認証を実装
3. ユーザー名/パスワード認証を併用
4. ファイアウォールで不要なポートを閉じる

---

### 問題10の解答

#### 1. センサーが使用すべきトピック名

```
sensor/sensor1/temperature
sensor/sensor2/temperature
sensor/sensor3/temperature
```

**設計理由**:
- 階層構造により管理しやすい
- ダッシュボードは `sensor/+/temperature` で一度にすべて購読可能
- センサーの追加が容易（sensor4、sensor5...）

#### 2. 温度データのQoSレベル

**QoS 0**

**理由**:
- 1秒ごとに送信されるため、1つ欠けても次のデータが来る
- リアルタイム性が重要で、配信保証は不要
- 低リソース消費でセンサーのバッテリーを節約

#### 3. Last Willメッセージの設定内容

**センサー1の例**:
```python
# センサー1のコード
client.will_set(
    topic="sensor/sensor1/status",
    payload="OFFLINE",
    qos=1,          # 確実に通知したいのでQoS 1
    retain=True     # 新しいダッシュボードにも状態を通知
)
client.connect("localhost", 1883)
client.publish("sensor/sensor1/status", "ONLINE", retain=True)
```

**ダッシュボード側**:
```python
# すべてのセンサーの温度を購読
client.subscribe("sensor/+/temperature", qos=0)

# すべてのセンサーの状態を購読
client.subscribe("sensor/+/status", qos=1)

def on_message(client, userdata, msg):
    if "status" in msg.topic:
        sensor_name = msg.topic.split('/')[1]  # "sensor1" など
        status = msg.payload.decode()
        if status == "OFFLINE":
            print(f"⚠️ {sensor_name} オフライン")
        else:
            print(f"✅ {sensor_name} オンライン")
    elif "temperature" in msg.topic:
        sensor_name = msg.topic.split('/')[1]
        temp = msg.payload.decode()
        print(f"{sensor_name}: {temp}°C")
```

**完全なトピック構造**:
```
sensor/
├── sensor1/
│   ├── temperature (QoS 0, Retain false)
│   └── status      (QoS 1, Retain true)
├── sensor2/
│   ├── temperature
│   └── status
└── sensor3/
    ├── temperature
    └── status
```

**設計のポイント**:
- **温度**: QoS 0、Retain不要（リアルタイムデータ）
- **状態**: QoS 1、Retain有効（確実な通知と新規接続時の状態確認）
- **Last Will**: 異常切断を自動検出してダッシュボードに通知
- **トピック分離**: 温度とステータスを分けることで柔軟性向上

---

## 🎯 採点基準

- **8問以上正解**: ✅ 優秀！次の章に進めます
- **6〜7問正解**: △ 基本は理解できています。間違えた部分を復習しましょう
- **5問以下**: ⚠️ もう一度、基礎解説ドキュメントを読み直すことをおすすめします

---

## 📚 さらに理解を深めるために

### 推奨する追加学習
1. **MQTT仕様書を読む**: [MQTT Version 5.0](https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html)
2. **公式ドキュメント**: [Eclipse Mosquitto Documentation](https://mosquitto.org/documentation/)
3. **実践演習**: 第2章で実際にBrokerを構築してみる

### よくある間違いと対策

| よくある間違い | 正しい理解 |
|:---|:---|
| QoS 2が最速だと思う | QoS 0が最速、QoS 2は最も遅い |
| Retain=trueで古いデータが残り続ける | 新しいメッセージで上書きされる |
| Last Willは必ず送信される | 正常切断では送信されない |
| `+`で複数階層にマッチする | `+`は1階層のみ、`#`が複数階層 |

---

**お疲れさまでした！**
このテストで基礎知識が身についたか確認できたはずです。次は実際にDockerでBrokerを構築してみましょう！

**次の章**: [第2章：Dockerブローカーのセットアップ](../step2/01_Dockerブローカー構築.md)
