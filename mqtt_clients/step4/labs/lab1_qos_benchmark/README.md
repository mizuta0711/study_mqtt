# 実験1：QoS性能比較ベンチマーク

## 📖 概要

このプログラムは、MQTT通信におけるQoS（Quality of Service）レベル0、1、2の性能差を比較するベンチマークツールです。各QoSレベルで100個のメッセージを送信し、配信速度を計測します。

## 🎯 学習目標

- 各QoSレベルの性能特性を理解する
- QoSレベルによる配信速度の違いを体験する
- 用途に応じた適切なQoSレベルの選択基準を学ぶ

## 🔍 QoSレベルとは

- **QoS 0（最大1回）**: 配信保証なし、最速
- **QoS 1（最低1回）**: 確認応答あり、重複の可能性あり
- **QoS 2（正確に1回）**: 完全な配信保証、最も遅い

## 🚀 使い方

### 前提条件

1. MQTTブローカー（Mosquitto）がlocalhost:1883で起動していること
2. paho-mqttライブラリがインストールされていること

```bash
pip install paho-mqtt
```

### 実行方法

```bash
python qos_benchmark.py
```

### 実行例

```
QoS 0: 0.0523秒 | 平均 0.52ms/msg
QoS 1: 0.1847秒 | 平均 1.85ms/msg
QoS 2: 0.3256秒 | 平均 3.26ms/msg
```

## 💡 結果の解釈

### 典型的な性能比較

- **QoS 0**: 最速。確認応答がないため、オーバーヘッドが最小
- **QoS 1**: QoS 0の約3-4倍の時間。ACK待機のため
- **QoS 2**: QoS 0の約6-8倍の時間。4段階ハンドシェイクのため

### どのQoSを使うべきか

| QoSレベル | 適用例 | メリット | デメリット |
|----------|--------|---------|-----------|
| QoS 0 | センサーデータ（頻繁な更新） | 高速、低負荷 | 配信保証なし |
| QoS 1 | コマンド送信、ログ収集 | バランスが良い | 重複の可能性 |
| QoS 2 | 決済情報、制御コマンド | 完全保証 | 最も遅い |

## 🔬 実験の拡張アイデア

1. **メッセージ数を変更**: `num_messages`の値を変えて試す
2. **ペイロードサイズの影響**: メッセージサイズを変更して比較
3. **ネットワーク遅延の影響**: リモートブローカーで試す
4. **並列送信**: 複数クライアントで同時送信

## 📝 コード解説

```python
for qos in [0, 1, 2]:
    start = time.time()

    for i in range(num_messages):
        client.publish(f"benchmark/qos{qos}", f"msg{i}", qos=qos)

    elapsed = time.time() - start
```

- 各QoSレベルで100メッセージを送信
- `time.time()`で開始・終了時刻を計測
- トピック名に`qos{qos}`を含めることで区別

## 🎓 まとめ

このベンチマークを通じて、以下が学べます：

- QoSレベルによる性能トレードオフ
- 信頼性とパフォーマンスのバランス
- アプリケーション要件に応じたQoS選択の重要性

**重要なポイント**: 高いQoSは常に優れているわけではなく、用途に応じた適切な選択が必要です。
